# MyEtcd - 一个完整的分布式键值存储系统

这是一个用Go语言实现的完整etcd克隆，专门用于学习分布式系统的核心原理和实践。项目从简单的键值存储开始，逐步实现了WAL(Write-Ahead Log)机制、ACID事务特性、Watch机制、租约系统、Raft一致性算法、性能监控、配置管理、结构化日志、Docker部署和性能基准测试等企业级功能。

## 🎯 项目背景与设计理念

### 为什么创建这个项目？

etcd是云原生领域最重要的基础组件之一，但它的源码实现相当复杂，对于初学者来说学习曲线陡峭。这个项目旨在通过**渐进式实现**的方式，让学习者能够：

1. **从简单到复杂**：从基础的键值存储开始，逐步添加高级功能
2. **理解核心原理**：每个模块都有详细的注释和设计思路说明
3. **实践最佳实践**：遵循Go语言的最佳实践和分布式系统的设计原则
4. **完整功能体验**：实现了一个功能完整的分布式存储系统

### 设计思路

#### 1. 模块化设计
```
MyEtcd采用分层架构设计，每个模块职责明确：
├── 存储层 (Storage Engine) - 负责数据存储和ACID事务
├── 一致性层 (Raft) - 负责分布式一致性
├── API层 (HTTP API) - 负责对外提供服务
├── 监控层 (Metrics) - 负责性能监控和指标收集
└── 部署层 (Docker) - 负责容器化部署
```

#### 2. 渐进式实现
项目按照功能复杂度分为三个阶段：
- **第一阶段**：基础键值存储 + WAL + ACID事务
- **第二阶段**：Watch + 租约 + 批量操作 + 范围查询
- **第三阶段**：Raft + 监控 + 配置 + 日志 + Docker + 基准测试

#### 3. 学习导向
每个模块都包含：
- **设计原理**：为什么这样设计
- **实现思路**：具体如何实现
- **代码注释**：详细的中文注释
- **示例代码**：如何使用这个功能
- **测试用例**：验证功能正确性

### 技术选型

- **语言**: Go (高性能、并发友好、简洁)
- **网络**: HTTP REST API (简单、通用)
- **存储**: 内存 + WAL (高性能 + 持久化)
- **一致性**: Raft算法 (易于理解、广泛应用)
- **监控**: Prometheus (云原生标准)
- **部署**: Docker (容器化标准)

## 🎯 学习目标

通过这个项目，你将学到：

### 核心系统概念
1. **WAL (Write-Ahead Log) 机制**：理解如何通过预写日志保证数据持久性
2. **ACID 事务特性**：学习原子性、一致性、隔离性、持久性的实现
3. **分布式一致性**：掌握Raft算法的核心原理和实现
4. **并发控制**：掌握读写锁和版本控制的实际应用
5. **存储引擎设计**：了解键值存储的核心原理

### 系统设计实践
6. **网络编程**：实践HTTP API服务器的设计和实现
7. **系统架构**：学习模块化设计和接口抽象
8. **事件驱动**：理解Watch机制和发布订阅模式
9. **资源管理**：学习租约机制和TTL管理
10. **批量处理**：理解批量操作的性能优势

### 工程化能力
11. **性能测试**：掌握性能基准测试的方法和实践
12. **监控系统**：学习如何设计和实现监控系统
13. **配置管理**：理解配置系统的重要性和实现
14. **日志系统**：掌握结构化日志和日志分级
15. **容器化部署**：学习Docker和容器编排
16. **文档编写**：理解技术文档的重要性

### 软件工程实践
17. **测试驱动开发**：学习如何编写有效的测试用例
18. **代码组织**：理解Go项目的最佳实践
19. **错误处理**：学习Go语言的错误处理模式
20. **性能优化**：理解如何分析和优化系统性能

## 🔥 核心特性

### 1. WAL (Write-Ahead Log) 机制详解

WAL是保证数据持久性的核心技术，也是数据库系统的基石：

```go
// WAL的工作流程：
// 1. 客户端发起写操作
// 2. 将操作记录写入WAL并同步到磁盘 (关键：保证持久性)
// 3. 将操作应用到内存中的数据结构 (关键：提高性能)
// 4. 返回成功响应给客户端
```

**设计思路：**
- **为什么需要WAL？** 如果直接修改内存数据，系统崩溃会导致数据丢失
- **为什么先写日志？** 日志是顺序写入，比随机修改数据结构更高效
- **为什么需要同步？** 确保日志真正写入磁盘，而不是停留在缓存中

**关键特性：**
- ✅ 预写日志：先写日志，再修改数据
- ✅ 数据完整性：CRC32校验和验证
- ✅ 崩溃恢复：系统重启后自动重放WAL
- ✅ 分段管理：避免单个日志文件过大
- ✅ 快照机制：定期生成快照，减少恢复时间

### 2. ACID 事务特性实现

事务是数据库系统的核心特性，MyEtcd实现了完整的ACID特性：

**设计思路：**
- **原子性**：通过事务日志和回滚机制保证
- **一致性**：通过数据验证和约束检查保证
- **隔离性**：通过读写锁保证并发安全
- **持久性**：通过WAL机制保证数据不丢失

### ACID 事务特性实现

#### 1. 原子性 (Atomicity)
```go
// 事务中的所有操作要么全部成功，要么全部失败
func (e *Engine) CommitTransaction(txnID string) error {
    // 设计思路：
    // 1. 先将事务操作写入WAL
    // 2. 然后按顺序执行所有操作
    // 3. 如果任何操作失败，回滚整个事务
    
    for _, op := range txn.Operations {
        if err := e.applyOperation(op); err != nil {
            // 任何操作失败，整个事务失败
            e.RollbackTransaction(txnID) // 回滚已执行的操作
            return err
        }
    }
    return nil
}
```

#### 2. 一致性 (Consistency)
```go
// 通过数据验证和约束检查保证一致性
func (e *Engine) Put(key string, value []byte, ttl int64) error {
    // 设计思路：
    // 1. 验证输入参数的合法性
    // 2. 检查数据完整性约束
    // 3. 维护索引和元数据的一致性
    
    if key == "" {
        return errors.New("key cannot be empty")
    }
    
    // 维护数据完整性约束
    // 写入WAL -> 更新内存 -> 返回成功
}
```

#### 3. 隔离性 (Isolation)
```go
// 使用读写锁保证并发安全
type Engine struct {
    mu sync.RWMutex  // 读写锁：多个读操作可以并发，写操作互斥
    data map[string]*KeyValue
}

func (e *Engine) Put(key string, value []byte, ttl int64) error {
    e.mu.Lock()         // 获取写锁，保证写操作的原子性
    defer e.mu.Unlock()
    // 执行写操作
}

func (e *Engine) Get(key string) (*KeyValue, error) {
    e.mu.RLock()         // 获取读锁，允许多个读操作并发
    defer e.mu.RUnlock()
    // 执行读操作
}
```

#### 4. 持久性 (Durability)
```go
// 通过WAL和快照机制保证持久性
func (e *Engine) Put(key string, value []byte, ttl int64) error {
    // 设计思路：
    // 1. 先写WAL，确保操作记录持久化
    // 2. 强制同步到磁盘，确保数据真正写入
    // 3. 再更新内存，提高读操作性能
    
    // 1. 写入WAL
    if err := e.wal.Append(record); err != nil {
        return err
    }
    
    // 2. 强制同步到磁盘 (关键步骤！)
    if err := e.wal.Sync(); err != nil {
        return err
    }
    
    // 3. 更新内存
    e.data[key] = newValue
    return nil
}
```

## 📁 项目架构与结构

### 整体架构设计

MyEtcd采用分层架构设计，每一层都有明确的职责：

```
┌─────────────────────────────────────────────────────────┐
│                    客户端层 (Client Layer)                │
│  HTTP API / gRPC / CLI / 客户端库                        │
├─────────────────────────────────────────────────────────┤
│                    接口层 (API Layer)                    │
│  REST API / 认证 / 限流 / 路由                           │
├─────────────────────────────────────────────────────────┤
│                   业务逻辑层 (Business Layer)             │
│  Watch / Lease / Transaction / Range Query               │
├─────────────────────────────────────────────────────────┤
│                   一致性层 (Consistency Layer)            │
│  Raft Algorithm / Leader Election / Log Replication     │
├─────────────────────────────────────────────────────────┤
│                   存储层 (Storage Layer)                 │
│  WAL / Snapshot / Memory Store / TTL Management          │
├─────────────────────────────────────────────────────────┤
│                   基础设施层 (Infrastructure Layer)       │
│  Metrics / Logging / Config / Network / File System     │
└─────────────────────────────────────────────────────────┘
```

### 项目目录结构

```
MyEtcd/
├── cmd/                     # 应用程序入口
│   └── server/
│       └── main.go         # 主程序入口，负责初始化和启动服务
├── internal/               # 内部包，不对外暴露
│   ├── wal/                # WAL (Write-Ahead Log) 实现
│   │   └── wal.go         # 预写日志核心实现，保证数据持久性
│   ├── storage/            # 存储引擎
│   │   └── engine.go      # ACID事务实现，内存存储引擎
│   ├── api/                # HTTP API服务
│   │   └── server.go      # REST API服务器，路由处理
│   ├── types/              # 数据类型定义
│   │   └── types.go       # 核心数据结构，请求/响应模型
│   ├── watch/              # Watch机制实现
│   │   └── watcher.go     # 键值变化监听，事件驱动
│   ├── lease/              # 租约机制实现
│   │   └── lease.go       # TTL和自动过期管理
│   ├── raft/               # Raft一致性算法
│   │   ├── raft.go        # Raft核心实现，状态机
│   │   ├── transport.go   # 网络传输层，节点间通信
│   │   ├── statemachine.go # 状态机接口和应用
│   │   └── cluster.go     # 集群管理，成员变更
│   ├── metrics/            # 性能监控系统
│   │   ├── metrics.go     # 指标收集和定义
│   │   ├── handler.go     # HTTP指标处理器
│   │   └── middleware.go  # HTTP中间件，请求统计
│   ├── config/             # 配置管理系统
│   │   └── config.go      # 配置加载、验证和热更新
│   ├── logger/             # 结构化日志系统
│   │   └── logger.go      # 多级别、多输出日志实现
│   └── benchmark/          # 性能基准测试
│       └── benchmark.go   # 基准测试框架和实现
├── tests/                  # 测试文件
│   ├── basic_test.go      # 基础功能测试
│   ├── watch_test.go      # Watch功能测试
│   ├── lease_test.go      # 租约功能测试
│   ├── raft_test.go       # Raft功能测试
│   └── benchmark_test.go  # 基准测试
├── examples/               # 示例代码和用法
│   ├── client/main.go     # 基础客户端示例
│   ├── watch/main.go      # Watch功能示例
│   ├── lease/main.go      # 租约功能示例
│   ├── raft/main.go       # Raft集群示例
│   ├── metrics/main.go    # 指标监控示例
│   ├── config/main.go     # 配置管理示例
│   ├── logger/main.go     # 日志系统示例
│   └── benchmark/main.go  # 基准测试示例
├── config/                 # 配置文件目录
│   └── config.json        # 默认配置文件
├── docs/                   # 项目文档
│   ├── implementation-summary.md  # 完整的项目实现总结
│   ├── docker.md          # Docker部署指南
│   └── benchmark.md       # 基准测试指南
├── monitoring/             # 监控配置
│   └── prometheus.yml     # Prometheus配置
├── nginx/                  # 负载均衡配置
│   ├── nginx.conf         # Nginx主配置
│   └── conf.d/            # 站点配置
├── docker-compose.yml      # Docker Compose配置
├── Dockerfile             # Docker镜像构建文件
├── Makefile               # 构建和开发脚本
└── README.md              # 项目说明文档
```

### 模块依赖关系

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│    API      │    │    Watch    │    │    Lease    │
└─────────────┘    └─────────────┘    └─────────────┘
       │                   │                   │
       └───────────────────┼───────────────────┘
                           │
┌─────────────────────────────────────────────────────────┐
│                    Storage Engine                       │
└─────────────────────────────────────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────┐
│                        WAL                              │
└─────────────────────────────────────────────────────────┘
```

## 🚀 快速开始

### 安装和运行

```bash
# 克隆项目
git clone <repository-url>
cd MyEtcd

# 安装依赖
go mod tidy

# 构建项目
make build

# 启动服务器
make run

# 运行测试
make test

# 运行客户端示例
make client

# 运行基准测试
make benchmark

# 查看所有可用命令
make help
```

### 手动运行

```bash
# 启动服务器
./bin/server -data-dir=./data -port=:2379

# 运行客户端示例
./bin/client
```

## 📡 API 接口

### 基础操作

```bash
# 设置键值
curl -X PUT -H "Content-Type: application/json" \
     -d '{"key":"test","value":"hello"}' \
     http://localhost:2379/v1/key/test

# 获取值
curl http://localhost:2379/v1/key/test

# 删除键
curl -X DELETE http://localhost:2379/v1/key/test

# 列出所有键
curl http://localhost:2379/v1/keys
```

### 事务操作

```bash
# 执行事务
curl -X POST -H "Content-Type: application/json" \
     -d '{
       "compare": [{"key":"counter", "op":"=", "value":"0"}],
       "success": [{"op":"PUT", "key":"counter", "value":"1"}],
       "failure": [{"op":"PUT", "key":"error", "value":"failed"}]
     }' \
     http://localhost:2379/v1/txn
```

### 系统信息

```bash
# 健康检查
curl http://localhost:2379/v1/health

# 系统状态
curl http://localhost:2379/v1/status

# 获取指标
curl http://localhost:2379/metrics
```

### 高级功能

```bash
# Watch键值变化
curl -X POST -H "Content-Type: application/json" \
     -d '{"key":"test","prefix":false,"prevKV":false}' \
     http://localhost:2379/v1/watch

# 范围查询
curl -X POST -H "Content-Type: application/json" \
     -d '{"key":"a","rangeEnd":"z","limit":10}' \
     http://localhost:2379/v1/range

# 批量操作
curl -X POST -H "Content-Type: application/json" \
     -d '{
       "operations": [
         {"op":"PUT", "key":"key1", "value":"value1"},
         {"op":"PUT", "key":"key2", "value":"value2"}
       ]
     }' \
     http://localhost:2379/v1/batch

# 租约管理
curl -X POST -H "Content-Type: application/json" \
     -d '{"ttl":60}' \
     http://localhost:2379/v1/lease/grant

## 🔍 代码学习指南

### 学习路径建议

为了帮助你更好地学习这个项目，我设计了三个学习阶段：

#### 第一阶段：核心基础 (1-2周)
**目标**：理解基本的键值存储和持久化机制

**学习顺序**：
1. **WAL机制** (`internal/wal/wal.go`)
   - 理解为什么需要预写日志
   - 学习如何保证数据持久性
   - 掌握文件I/O和同步机制

2. **存储引擎** (`internal/storage/engine.go`)
   - 理解内存存储结构
   - 学习ACID事务的实现
   - 掌握并发控制机制

3. **API服务器** (`internal/api/server.go`)
   - 理解REST API设计
   - 学习HTTP路由和处理
   - 掌握错误处理模式

#### 第二阶段：高级功能 (2-3周)
**目标**：掌握分布式系统的核心概念

**学习顺序**：
1. **Watch机制** (`internal/watch/watcher.go`)
   - 理解事件驱动架构
   - 学习发布订阅模式
   - 掌握实时通知机制

2. **租约系统** (`internal/lease/lease.go`)
   - 理解TTL和过期机制
   - 学习资源管理
   - 掌握定时器和清理策略

3. **范围查询和批量操作** (`internal/storage/engine.go`)
   - 理解数据索引和查询优化
   - 学习批量处理的优势
   - 掌握分页和限流技巧

#### 第三阶段：分布式系统 (3-4周)
**目标**：理解分布式一致性系统工程实践

**学习顺序**：
1. **Raft算法** (`internal/raft/`)
   - 理解分布式一致性原理
   - 学习领导者选举和日志复制
   - 掌握状态机和应用层协议

2. **监控系统** (`internal/metrics/`)
   - 理解监控和可观测性
   - 学习指标收集和导出
   - 掌握性能分析技巧

3. **配置和日志** (`internal/config/`, `internal/logger/`)
   - 理解配置管理最佳实践
   - 学习结构化日志设计
   - 掌握运维友好的系统设计

### 详细学习指南

#### 1. 理解WAL机制

**重点文件**: [`internal/wal/wal.go`](internal/wal/wal.go:1)

**核心概念**：
```go
// WAL的设计哲学：
// 1. 顺序写入：磁盘顺序写入比随机写入快得多
// 2. 先写日志：确保操作不会丢失
// 3. 后写数据：提高读操作性能
// 4. 定期快照：减少恢复时间

// WAL核心方法学习顺序：
// 1. NewWAL() - 创建WAL实例，理解文件组织方式
// 2. Append() - 追加记录，核心方法，理解序列化
// 3. Sync() - 同步到磁盘，关键步骤，理解fsync
// 4. ReadAll() - 读取所有记录，理解反序列化
// 5. Truncate() - 截断日志，理解日志清理
```

**设计思路分析**：
- **为什么需要WAL？**
  - 内存数据易失，系统崩溃会丢失数据
  - 直接写入磁盘太慢，影响性能
  - WAL提供了性能和持久性的平衡

- **为什么需要CRC32？**
  - 检测数据损坏，保证数据完整性
  - 磁盘可能发生位翻转，需要校验机制
  - 网络传输也可能引入错误

- **为什么需要分段？**
  - 单个文件过大，管理困难
  - 便于清理旧日志，控制磁盘使用
  - 并发读写时减少锁竞争

**实践练习**：
1. 尝试修改WAL的序列化格式，添加新的字段
2. 实现一个简单的WAL查看工具，可以解析WAL文件
3. 测试在不同故障情况下的恢复能力

#### 2. 理解ACID实现

**重点文件**: [`internal/storage/engine.go`](internal/storage/engine.go:1)

**设计思路深度解析**：

```go
// 事务的设计哲学：
// 1. 原子性：通过事务日志保证，要么全部成功，要么全部失败
// 2. 一致性：通过数据验证保证，数据始终处于有效状态
// 3. 隔离性：通过读写锁保证，并发操作不会相互干扰
// 4. 持久性：通过WAL保证，提交的数据不会丢失

// ACID核心方法学习顺序：
// 1. Put() - 理解单操作的持久性实现
// 2. BeginTransaction() - 理解事务的开始和准备
// 3. CommitTransaction() - 理解事务的提交和确认
// 4. RollbackTransaction() - 理解事务的回滚和恢复
// 5. Get() - 理解读操作的一致性保证
```

**并发控制深度分析**：

```go
// 读写锁的设计思路：
// 1. 读操作可以并发：多个客户端同时读取不会冲突
// 2. 写操作必须互斥：同时修改会导致数据不一致
// 3. 读写不能同时：写时会阻塞读，保证数据一致性

// 锁的粒度设计：
// - 粗粒度锁：简单但性能差，整个引擎一把锁
// - 细粒度锁：复杂但性能好，每个key一把锁
// - MyEtcd选择粗粒度锁：简单可靠，适合学习
```

**实践练习**：
1. 实现一个读提交隔离级别的事务
2. 添加事务超时机制，防止长时间阻塞
3. 实现事务的嵌套支持

#### 3. 理解并发控制

**并发模式分析**：

```go
// MyEtcd中的并发控制模式：
// 1. 读写锁模式：适合读多写少的场景
// 2. 乐观锁模式：通过版本号检测冲突
// 3. 悲观锁模式：直接加锁防止冲突

// 锁的使用最佳实践：
// 1. 尽早加锁，尽快释放
// 2. 避免在锁内进行I/O操作
// 3. 使用defer确保锁一定会被释放
// 4. 避免死锁：按固定顺序获取多个锁
```

**性能优化思路**：
- **减少锁持有时间**：将耗时操作移到锁外
- **减少锁竞争**：使用分片或分段锁
- **避免死锁**：按固定顺序获取锁，设置超时

#### 4. 理解Watch机制

**重点文件**: [`internal/watch/watcher.go`](internal/watch/watcher.go:1)

**设计哲学**：
```go
// Watch机制的设计思路：
// 1. 事件驱动：基于事件的异步通知机制
// 2. 推送模式：服务器主动推送变化，而不是客户端轮询
// 3. 过滤机制：支持前缀匹配和精确匹配
// 4. 历史数据：可选择返回变化前的值

// 实现关键技术：
// 1. 观察者模式：经典的发布订阅模式
// 2. 事件队列：缓存事件，防止丢失
// 3. 批量推送：提高网络效率
// 4. 连接管理：处理客户端断开和重连
```

**实践练习**：
1. 实现一个Watch的客户端库
2. 添加Watch的过滤功能，支持更复杂的条件
3. 实现Watch的重试机制，处理网络故障

#### 5. 理解Raft算法

**重点文件**: [`internal/raft/raft.go`](internal/raft/raft.go:1)

**Raft算法核心概念**：
```go
// Raft的设计哲学：
// 1. 可理解性：比Paxos更容易理解和实现
// 2. 领导者主导：简化一致性协议的复杂性
// 3. 日志复制：通过日志复制保证一致性
// 4. 安全性：在任何情况下都不会出现数据不一致

// Raft核心组件：
// 1. Leader Election：领导者选举
// 2. Log Replication：日志复制
// 3. Safety：安全性保证
// 4. Cluster Membership：集群成员变更
```

**学习建议**：
1. 先读Raft论文，理解算法原理
2. 再看代码实现，理解具体细节
3. 运行测试用例，观察算法行为
4. 修改参数，测试不同场景

#### 6. 理解监控系统

**重点文件**: [`internal/metrics/metrics.go`](internal/metrics/metrics.go:1)

**监控设计思路**：
```go
// 监控系统的设计原则：
// 1. 可观测性：系统应该能够解释自己的行为
// 2. 最小侵入：监控不应该影响系统性能
// 3. 标准化：使用行业标准格式
// 4. 实时性：及时发现问题

// 指标分类：
// 1. 计数器：只增不减，如总请求数
// 2. 计量器：可增可减，如当前连接数
// 3. 直方图：记录分布，如请求延迟
// 4. 摘要：统计信息，如平均值、最大值
```

### 最佳实践总结

#### 代码组织
1. **模块化设计**：每个模块职责单一，接口清晰
2. **依赖注入**：便于测试和扩展
3. **错误处理**：统一的错误处理模式
4. **日志记录**：关键操作都有日志记录

#### 性能优化
1. **批量操作**：减少网络开销
2. **缓存策略**：提高读操作性能
3. **连接池**：复用网络连接
4. **异步处理**：非阻塞I/O

#### 可靠性保证
1. **数据校验**：CRC32校验和
2. **故障恢复**：WAL重放机制
3. **健康检查**：定期检查系统状态
4. **优雅关闭**：正确处理关闭信号

#### 安全考虑
1. **输入验证**：验证所有输入参数
2. **资源限制**：防止资源耗尽
3. **并发控制**：避免竞态条件
4. **错误处理**：不暴露敏感信息

## 🧪 测试和验证

### 运行测试

```bash
# 运行所有测试
make test

# 运行特定测试
go test -v ./tests/ -run TestBasicOperations
go test -v ./tests/ -run TestTransaction
go test -v ./tests/ -run TestWALRecovery
```

### 测试覆盖的功能

- ✅ 基础CRUD操作
- ✅ TTL过期机制
- ✅ ACID事务特性
- ✅ WAL崩溃恢复
- ✅ 并发安全性
- ✅ HTTP API功能
- ✅ Watch机制
- ✅ 范围查询
- ✅ 批量操作
- ✅ 租约机制
- ✅ Raft一致性算法
- ✅ 性能监控
- ✅ 配置管理
- ✅ 结构化日志
- ✅ Docker支持

## 📚 深入学习

### 扩展练习

1. **实现Raft一致性算法**
   - 添加领导者选举
   - 实现日志复制
   - 处理网络分区

2. **优化性能**
   - 实现内存池
   - 添加批量写入
   - 优化锁粒度

3. **增强功能** ✅ 已实现
   - 添加Watch机制 ✅
   - 实现分布式锁
   - 支持范围查询 ✅
   - 批量操作支持 ✅
   - 租约机制 ✅
   - Raft一致性算法 ✅
   - 性能监控 ✅
   - 配置管理 ✅
   - 结构化日志 ✅
   - Docker支持 ✅
   - 性能基准测试 ✅

### 推荐阅读

- 《Designing Data-Intensive Applications》
- etcd官方文档
- Raft论文原文

## 🤝 贡献指南

欢迎提交Issue和Pull Request来改进这个学习项目！

## 📄 许可证

MIT License

---

## 📊 性能基准测试

MyEtcd提供了全面的性能基准测试工具，用于评估系统在各种工作负载下的性能表现。

### 运行基准测试

```bash
# 运行默认基准测试
make benchmark

# 运行自定义基准测试
make benchmark-custom

# 运行大规模基准测试
make benchmark-large

# 运行压力测试
make benchmark-stress

# 生成基准测试报告
make benchmark-report

# 运行基准测试单元测试
make benchmark-test
```

### 基准测试指标

- **吞吐量 (ops/s)**: 每秒操作数
- **平均延迟**: 操作的平均响应时间
- **P99延迟**: 99%的操作的响应时间
- **错误率**: 失败操作的百分比

详细使用说明请参考 [基准测试指南](docs/benchmark.md)。

## 📖 完整文档

为了帮助你更好地理解和使用这个项目，我们提供了完整的文档：

- **[实现总结](docs/implementation-summary.md)** - 完整的项目实现总结，包含所有模块的详细说明
- **[基准测试文档](docs/benchmark.md)** - 性能测试和使用指南
- **[Docker部署文档](docs/docker.md)** - 容器化部署指南

## 🐳 Docker 部署

MyEtcd支持Docker容器化部署，提供单节点、集群和监控部署方案。

### Docker 命令

```bash
# 构建Docker镜像
make docker-build

# 运行单节点容器
make docker-run

# 启动单节点集群
make docker-up-single

# 启动多节点集群
make docker-up-cluster

# 启动监控环境
make docker-up-monitoring

# 查看容器状态
make docker-ps

# 查看容器日志
make docker-logs

# 清理Docker资源
make docker-clean
```

详细部署指南请参考 [Docker部署指南](docs/docker.md)。

## ❓ 常见问题解答

### 技术问题

**Q: MyEtcd和真正的etcd有什么区别？**
A: MyEtcd是一个学习项目，专注于核心原理的实现，而etcd是生产级系统，包含更多优化和安全特性。主要区别：
- MyEtcd使用HTTP API，etcd支持gRPC
- MyEtcd实现了简化的Raft，etcd有更完整的实现
- MyEtcd缺少一些生产级特性，如安全认证、备份等

**Q: 为什么选择Go语言实现？**
A: Go语言有以下优势：
- 内置的并发支持，适合分布式系统
- 简洁的语法，便于理解和学习
- 优秀的性能，接近C/C++
- 丰富的标准库，减少开发工作量
- 活跃的社区，良好的生态支持

**Q: WAL的性能如何优化？**
A: WAL的优化策略：
- 批量写入：积累多个操作后一次性写入
- 异步同步：使用后台线程定期同步
- 缓冲区管理：合理设置缓冲区大小
- 文件预分配：避免文件扩展的开销

### 学习问题

**Q: 如何学习Raft算法？**
A: 建议的学习路径：
1. 先读Raft论文，理解算法原理
2. 使用Raft可视化工具，观察算法行为
3. 阅读MyEtcd的Raft实现，理解代码细节
4. 修改参数，测试不同场景
5. 尝试实现简化版本的Raft

**Q: 项目太复杂，如何开始学习？**
A: 分阶段学习建议：
1. 先运行项目，体验基本功能
2. 阅读WAL实现，理解持久化机制
3. 学习存储引擎，理解ACID实现
4. 逐步深入高级功能
5. 最后学习分布式一致性算法

**Q: 需要什么基础知识？**
A: 推荐的基础知识：
- Go语言基础：语法、并发、错误处理
- 操作系统基础：文件系统、进程、网络
- 数据库基础：事务、索引、并发控制
- 分布系统基础：一致性、容错、复制

### 实践问题

**Q: 如何测试分布式功能？**
A: 测试方法：
1. 使用Docker启动多个节点
2. 模拟网络分区和节点故障
3. 观察系统行为和恢复过程
4. 使用基准测试评估性能
5. 阅读日志，分析问题原因

**Q: 如何调试分布式系统？**
A: 调试技巧：
1. 详细日志记录关键操作
2. 指标监控收集运行数据
3. 分布式追踪跟踪请求流程
4. 单元测试验证组件功能
5. 集成测试验证系统行为

**Q: 性能优化有什么建议？**
A: 优化方向：
1. 减少锁竞争和锁持有时间
2. 批量操作减少网络开销
3. 缓存热点数据提高响应速度
4. 异步处理提高吞吐量
5. 连接池复用网络连接

## 🤝 贡献指南

我们欢迎各种形式的贡献，无论是代码、文档、测试还是建议！

### 贡献类型

1. **代码贡献**
   - 修复bug和实现新功能
   - 性能优化和代码重构
   - 添加测试用例和文档

2. **文档贡献**
   - 改进README和API文档
   - 添加教程和示例代码
   - 翻译文档到其他语言

3. **测试贡献**
   - 添加单元测试和集成测试
   - 提高测试覆盖率
   - 添加性能基准测试

4. **反馈和建议**
   - 报告bug和使用问题
   - 提出功能建议和改进意见
   - 分享使用经验和最佳实践

### 贡献流程

1. **Fork项目**：在GitHub上fork项目到你的账户
2. **创建分支**：为你的贡献创建一个特性分支
3. **编写代码**：实现你的功能或修复
4. **编写测试**：为你的代码添加测试
5. **提交PR**：创建Pull Request到主项目
6. **代码审查**：等待维护者审查和合并

### 开发指南

1. **代码风格**
   - 遵循Go语言官方代码规范
   - 使用gofmt格式化代码
   - 添加详细的中文注释

2. **提交信息**
   - 使用清晰的提交信息
   - 说明修改的原因和内容
   - 关联相关的Issue

3. **测试要求**
   - 新功能必须包含测试
   - 测试覆盖率不低于80%
   - 所有测试必须通过

4. **文档要求**
   - 更新相关文档
   - 添加使用示例
   - 说明设计思路

### 社区准则

1. **友好交流**：尊重他人，保持友好
2. **建设性反馈**：提供建设性的意见和建议
3. **耐心等待**：维护者会尽快回复，请耐心等待
4. **学习心态**：这是一个学习项目，鼓励提问和讨论

## 🌟 项目亮点总结

### 技术亮点

1. **完整的分布式系统实现**：从底层存储到上层API，实现了完整的分布式键值存储系统
2. **渐进式学习路径**：从简单到复杂，循序渐进地学习分布式系统概念
3. **详细的中文注释**：每个模块都有详细的设计思路和实现说明
4. **丰富的示例代码**：每个功能都有对应的使用示例
5. **全面的测试覆盖**：包含单元测试、集成测试和性能基准测试

### 学习亮点

1. **理论与实践结合**：不仅有理论解释，还有实际代码实现
2. **问题导向学习**：通过解决实际问题来学习技术概念
3. **多维度知识覆盖**：涵盖存储、网络、并发、分布式等多个领域
4. **工程化实践**：学习如何构建可维护、可扩展的系统

### 教学亮点

1. **设计思路分析**：不仅讲"怎么做"，还讲"为什么这么做"
2. **常见问题解答**：解决学习过程中可能遇到的困惑
3. **最佳实践指导**：提供工业级的开发建议
4. **扩展练习建议**：为进一步学习指明方向

## 🎯 学习成果

通过完成这个项目的学习，你将获得：

### 技术能力
- 深入理解分布式系统的核心原理
- 掌握Go语言的并发编程和系统编程
- 学会设计和实现高性能的存储系统
- 具备分布式系统调试和优化的能力

### 工程能力
- 掌握模块化设计和接口抽象
- 学会编写可测试、可维护的代码
- 理解系统监控和可观测性的重要性
- 具备容器化部署和运维的经验

### 学习能力
- 培养阅读和理解复杂系统源码的能力
- 学会如何分析和解决技术问题
- 掌握自主学习和持续改进的方法
- 建立分布式系统的知识体系

---

**注意：** 这个项目仅用于学习目的，不建议在生产环境中使用。真正的etcd要复杂得多，包含了许多生产环境必需的特性。

## 📞 联系方式

如果你有任何问题或建议，欢迎通过以下方式联系：

- **GitHub Issues**: [提交问题](https://github.com/yourusername/myetcd/issues)
- **Pull Requests**: [贡献代码](https://github.com/yourusername/myetcd/pulls)
- **讨论区**: [参与讨论](https://github.com/yourusername/myetcd/discussions)

## 🙏 致谢

感谢以下开源项目的启发和帮助：

- [etcd](https://etcd.io/) - 分布式键值存储系统的参考实现
- [Raft](https://raft.github.io/) - 一致性算法的理论基础
- [Go](https://golang.org/) - 优秀的编程语言和生态系统

感谢所有为这个项目做出贡献的开发者和学习者！

---

**Happy Coding! 🚀**

如果这个项目对你的学习有帮助，请考虑给个⭐️支持一下！
